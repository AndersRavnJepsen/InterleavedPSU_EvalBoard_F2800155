/**
 * These arguments were used when this file was generated. They will be automatically applied on subsequent loads
 * via the GUI or CLI. Run CLI with '--help' for additional information on how to override these arguments.
 * @cliArgs --device "F280015x" --part "F280015x_64PM" --package "64PM" --context "system" --product "C2000WARE@6.00.00.00"
 * @v2CliArgs --device "TMS320F2800155" --package "64PM" --context "system" --product "C2000WARE@6.00.00.00"
 * @versions {"tool":"1.24.0+4110"}
 */

/**
 * Import the modules used in this configuration.
 */
const adc            = scripting.addModule("/driverlib/adc.js", {}, false);
const adc1           = adc.addInstance();
const analog         = scripting.addModule("/driverlib/analog.js", {}, false);
const analog1        = analog.addInstance();
const asysctl        = scripting.addModule("/driverlib/asysctl.js");
const cmpss_lite     = scripting.addModule("/driverlib/cmpss_lite.js", {}, false);
const cmpss_lite1    = cmpss_lite.addInstance();
const device_support = scripting.addModule("/driverlib/device_support.js");
const epwm           = scripting.addModule("/driverlib/epwm.js", {}, false);
const epwm1          = epwm.addInstance();
const epwm2          = epwm.addInstance();
const epwm3          = epwm.addInstance();
const epwm4          = epwm.addInstance();
const epwmxbar       = scripting.addModule("/driverlib/epwmxbar.js", {}, false);
const epwmxbar1      = epwmxbar.addInstance();
const gpio           = scripting.addModule("/driverlib/gpio.js", {}, false);
const gpio1          = gpio.addInstance();
const sysctl         = scripting.addModule("/driverlib/sysctl.js");
const controller     = scripting.addModule("/libraries/control/dcl/controller.js", {}, false);
const controller1    = controller.addInstance();
const controller2    = controller.addInstance();
const controller3    = controller.addInstance();
const controller4    = controller.addInstance();
const FPUfastRTS     = scripting.addModule("/libraries/math/FPUfastRTS/FPUfastRTS.js", {}, false);
const FPUfastRTS1    = FPUfastRTS.addInstance();
const CMD            = scripting.addModule("/utilities/cmd_tool/cmd_syscfg/source/CMD");
const CMD1           = CMD.addInstance();

/**
 * Write custom configuration values to the imported modules.
 */
adc1.$name                    = "ADC_A";
adc1.adcClockPrescaler        = "ADC_CLK_DIV_2_0";
adc1.enabledSOCs              = ["ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3","ADC_SOC_NUMBER4"];
adc1.soc1Channel              = "ADC_CH_ADCIN3";
adc1.soc1Trigger              = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc2Channel              = "ADC_CH_ADCIN2";
adc1.soc2Trigger              = "ADC_TRIGGER_EPWM2_SOCA";
adc1.soc3Channel              = "ADC_CH_ADCIN15";
adc1.soc3Trigger              = "ADC_TRIGGER_EPWM3_SOCA";
adc1.soc4Channel              = "ADC_CH_ADCIN14";
adc1.soc4Trigger              = "ADC_TRIGGER_EPWM4_SOCA";
adc1.interruptPulseMode       = "ADC_PULSE_END_OF_CONV";
adc1.enabledInts              = ["ADC_INT_NUMBER1"];
adc1.interrupt1SOCSource      = "ADC_SOC_NUMBER4";
adc1.registerInterrupts       = ["1"];
adc1.useInterrupts            = false;
adc1.soc1SampleWindow         = 15;
adc1.soc2SampleWindow         = 15;
adc1.soc3SampleWindow         = 15;
adc1.soc4SampleWindow         = 15;
adc1.enabledPPBs              = ["ADC_PPB_NUMBER1"];
adc1.ppb1SOCNumber            = "ADC_SOC_NUMBER1";
adc1.ppb1EnableTwosComplement = true;
adc1.ppb1ReferenceOffset      = 4095;
adc1.enableInterrupt1         = true;
scripting.suppress("The maximum frequency of ADC for this device is 50MHz\\. ADC Clock Prescaler should be selected accordingly\\.", adc1, "adcClockPrescaler");

asysctl.analogReferenceVoltage = "1P65";

cmpss_lite1.$name               = "cmpss3";
cmpss_lite1.cmpssLiteBase       = "CMPSSLITE3_BASE";
cmpss_lite1.asysCMPHPMXSELValue = "3";
cmpss_lite1.asysCMPHNMXSELValue = "0";
cmpss_lite1.asysCMPLNMXSELValue = "0";
cmpss_lite1.asysCMPLPMXSELValue = "4";
cmpss_lite1.highCompInvert      = true;
cmpss_lite1.enableModule        = true;
cmpss_lite1.sampleWindowHigh    = 8;
cmpss_lite1.thresholdHigh       = 6;
cmpss_lite1.dacValHigh          = 1500;

analog1.$name            = "myANALOGPinMux0";
adc1.analog              = analog1;
analog1.useCase          = "CUSTOM";
analog1.useInterfacePins = ["A15/C7","A2/C9, GPIO224","A3/C5, GPIO242","C4/A14"];
cmpss_lite1.analog       = analog1;

epwm1.$name                                                         = "ePWM2";
epwm1.epwmGlobalLoad_gld                                            = true;
epwm1.epwmGlobalLoad_gldMode                                        = "EPWM_GL_LOAD_PULSE_SYNC";
epwm1.epwmGlobalLoad_gldPeriod                                      = "1";
epwm1.epwmTimebase_hsClockDiv                                       = "EPWM_HSCLOCK_DIVIDER_1";
epwm1.epwmTimebase_period                                           = 600;
epwm1.epwmTimebase_periodLink                                       = "EPWM_LINK_WITH_EPWM_1";
epwm1.epwmTimebase_periodGld                                        = true;
epwm1.epwmTimebase_counterMode                                      = "EPWM_COUNTER_MODE_UP_DOWN";
epwm1.epwmTimebase_phaseEnable                                      = true;
epwm1.epwmTimebase_phaseShift                                       = 300;
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA      = "EPWM_AQ_OUTPUT_HIGH";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA    = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerEnable                     = true;
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerSource                     = "EPWM_SOC_TBCTR_PERIOD";
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar             = "1";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_ZERO         = "EPWM_AQ_OUTPUT_HIGH";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_PERIOD       = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmCounterCompare_cmpA                                       = 540;
epwm1.epwmDigitalCompare_EPWM_DC_MODULE_A_EPWM_DC_EVENT_1_eventSync = "EPWM_DC_EVENT_INPUT_NOT_SYNCED";
epwm1.epwm.$assign                                                  = "EPWM2";
epwm1.epwm.epwm_aPin.$assign                                        = "GPIO41";
epwm1.epwm.epwm_bPin.$assign                                        = "GPIO40";

epwm2.$name                                                      = "ePWM3";
epwm2.epwmGlobalLoad_gld                                         = true;
epwm2.epwmGlobalLoad_gldMode                                     = "EPWM_GL_LOAD_PULSE_SYNC";
epwm2.epwmGlobalLoad_gldPeriod                                   = "1";
epwm2.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm2.epwmTimebase_period                                        = 600;
epwm2.epwmTimebase_periodLink                                    = "EPWM_LINK_WITH_EPWM_1";
epwm2.epwmTimebase_periodGld                                     = true;
epwm2.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm2.epwmTimebase_phaseEnable                                   = true;
epwm2.epwmTimebase_phaseShift                                    = 600;
epwm2.epwmCounterCompare_cmpA                                    = 540;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_HIGH";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_LOW";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_ZERO      = "EPWM_AQ_OUTPUT_HIGH";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_PERIOD    = "EPWM_AQ_OUTPUT_LOW";
epwm2.epwmEventTrigger_EPWM_SOC_A_triggerEnable                  = true;
epwm2.epwmEventTrigger_EPWM_SOC_A_triggerSource                  = "EPWM_SOC_TBCTR_PERIOD";
epwm2.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar          = "1";
epwm2.epwm.$assign                                               = "EPWM3";
epwm2.epwm.epwm_aPin.$assign                                     = "GPIO0";
epwm2.epwm.epwm_bPin.$assign                                     = "GPIO1";

epwm3.$name                                                      = "ePWM4";
epwm3.epwmGlobalLoad_gld                                         = true;
epwm3.epwmGlobalLoad_gldMode                                     = "EPWM_GL_LOAD_PULSE_SYNC";
epwm3.epwmGlobalLoad_gldPeriod                                   = "1";
epwm3.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm3.epwmTimebase_period                                        = 600;
epwm3.epwmTimebase_periodLink                                    = "EPWM_LINK_WITH_EPWM_1";
epwm3.epwmTimebase_periodGld                                     = true;
epwm3.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm3.epwmTimebase_phaseEnable                                   = true;
epwm3.epwmTimebase_phaseShift                                    = 300;
epwm3.epwmTimebase_counterModeAfterSync                          = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm3.epwmCounterCompare_cmpA                                    = 540;
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_HIGH";
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_LOW";
epwm3.epwmEventTrigger_EPWM_SOC_A_triggerEnable                  = true;
epwm3.epwmEventTrigger_EPWM_SOC_A_triggerSource                  = "EPWM_SOC_TBCTR_PERIOD";
epwm3.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar          = "1";
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_ZERO      = "EPWM_AQ_OUTPUT_HIGH";
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_PERIOD    = "EPWM_AQ_OUTPUT_LOW";
epwm3.epwm.$assign                                               = "EPWM4";
epwm3.epwm.epwm_aPin.$assign                                     = "GPIO2";
epwm3.epwm.epwm_bPin.$assign                                     = "GPIO3";

epwm4.$name                                                         = "ePWM1";
epwm4.epwmGlobalLoad_gld                                            = true;
epwm4.epwmGlobalLoad_gldPeriod                                      = "1";
epwm4.epwmGlobalLoad_enableOneShot                                  = true;
epwm4.epwmGlobalLoad_oneShotMode                                    = true;
epwm4.epwmTimebase_hsClockDiv                                       = "EPWM_HSCLOCK_DIVIDER_1";
epwm4.epwmTimebase_period                                           = 600;
epwm4.epwmTimebase_periodGld                                        = true;
epwm4.epwmTimebase_counterMode                                      = "EPWM_COUNTER_MODE_UP_DOWN";
epwm4.epwmTimebase_counterModeAfterSync                             = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm4.epwmTimebase_phaseEnable                                      = true;
epwm4.epwmTimebase_syncInPulseSource                                = "EPWM_SYNC_IN_PULSE_SRC_DISABLE";
epwm4.epwmTimebase_syncOutPulseMode                                 = ["EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO","EPWM_SYNC_OUT_PULSE_ON_SOFTWARE"];
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode               = true;
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_onetimeSwForceAction     = "EPWM_AQ_OUTPUT_LOW";
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA      = "EPWM_AQ_OUTPUT_HIGH";
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA    = "EPWM_AQ_OUTPUT_LOW";
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_B_shadowMode               = true;
epwm4.epwmCounterCompare_cmpB                                       = 1;
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerEnable                     = true;
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerSource                     = "EPWM_SOC_TBCTR_PERIOD";
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar             = "1";
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_ZERO         = "EPWM_AQ_OUTPUT_HIGH";
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_PERIOD       = "EPWM_AQ_OUTPUT_LOW";
epwm4.epwmDigitalCompare_EPWM_DC_MODULE_A_EPWM_DC_EVENT_1_eventSync = "EPWM_DC_EVENT_INPUT_NOT_SYNCED";
epwm4.epwmDigitalCompare_EPWM_TZ_DC_OUTPUT_A1                       = "EPWM_TZ_EVENT_DCXH_HIGH";
epwm4.epwmDigitalCompare_EPWM_DC_TYPE_DCAH                          = "EPWM_DC_TRIP_TRIPIN4";
epwm4.epwmDigitalCompare_EPWM_DC_TYPE_DCAL                          = "EPWM_DC_TRIP_TRIPIN4";
epwm4.epwmTripZone_EPWM_TZ_ACTION_EVENT_DCAEVT1                     = "EPWM_TZ_ACTION_LOW";
epwm4.epwmTripZone_useAdvancedEPWMTripZoneActions                   = true;
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_TZA_D                   = "EPWM_TZ_ADV_ACTION_LOW";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_TZA_U                   = "EPWM_TZ_ADV_ACTION_LOW";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_DCxEVT1_U_A             = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_DCxEVT1_D_A             = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmCounterCompare_cmpA                                       = 540;
epwm4.epwmDigitalCompare_EPWM_DC_MODULE_A_EPWM_DC_EVENT_2_eventSync = "EPWM_DC_EVENT_INPUT_NOT_SYNCED";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_TZB_D                   = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_TZB_U                   = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_DCxEVT2_U_A             = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_DCxEVT2_D_A             = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_DCxEVT1_U_B             = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_DCxEVT1_D_B             = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_DCxEVT2_U_B             = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_EPWM_TZ_ADV_ACTION_EVENT_DCxEVT2_D_B             = "EPWM_TZ_ADV_ACTION_DISABLE";
epwm4.epwmTripZone_oneShotSource                                    = ["EPWM_TZ_SIGNAL_DCAEVT1"];
epwm4.epwm.$assign                                                  = "EPWM1";
epwm4.epwm.epwm_aPin.$assign                                        = "GPIO4";
epwm4.epwm.epwm_bPin.$assign                                        = "GPIO5";

epwmxbar1.$name           = "epwmxbar0";
epwmxbar1.useSourceSelect = true;
epwmxbar1.sourceSignals   = ["CMPSS3_CTRIPH"];

gpio1.$name             = "gpio28";
gpio1.direction         = "GPIO_DIR_MODE_OUT";
gpio1.writeInitialValue = true;
gpio1.gpioPin.$assign   = "A16/C16, GPIO28";

controller1.controllerChoice = "PI";
controller1.Umin             = "0.0f";
controller1.Imin             = "0.0f";
controller1.$name            = "pi_current1";
controller1.Ki               = "0.001f";
controller1.Kp               = "0.006f";

controller2.controllerChoice = "PI";
controller2.Kp               = "0.001f";
controller2.Ki               = "0.0001f";
controller2.Umin             = "0.0f";
controller2.Imin             = "0.0f";
controller2.$name            = "pi_current2";

controller3.controllerChoice = "PI";
controller3.Kp               = "0.001f";
controller3.Ki               = "0.0001f";
controller3.Umin             = "0.0f";
controller3.Imin             = "0.0f";
controller3.$name            = "pi_current3";

controller4.controllerChoice = "PI";
controller4.Kp               = "0.001f";
controller4.Ki               = "0.0001f";
controller4.Umin             = "0.0f";
controller4.Imin             = "0.0f";
controller4.$name            = "pi_current4";

FPUfastRTS1.$name = "fpu";

CMD.activateCMD = true;

CMD1.$name                                 = "CMD0";
CMD1.sectionMemory_ramfunc                 = ["RAMM0"];
CMD1.sectionMemory_cinit                   = ["RAMM0"];
CMD1.sectionMemory_switch                  = ["RAMM0"];
CMD1.sectionMemory_stack                   = ["RAMM1"];
CMD1.sectionMemory_init_array              = ["RAMM0"];
CMD1.sectionMemory_text                    = ["RAMLS_ALL"];
CMD1.sectionMemory_bss                     = ["RAMLS_ALL"];
CMD1.sectionMemory_const                   = ["RAMLS_ALL"];
CMD1.sectionMemory_data                    = ["RAMLS_ALL"];
CMD1.sectionMemory_sysmem                  = ["RAMLS_ALL"];
CMD1.RAMLSmemoryCombination.create(1);
CMD1.RAMLSmemoryCombination[0].$name       = "RAMLS_ALL";
CMD1.RAMLSmemoryCombination[0].combination = ["RAMLS0","RAMLS1"];
CMD1.userSection.create(2);
CMD1.userSection[0].$name                  = "DCL_funcs";
CMD1.userSection[0].sectionName            = "dclfuncs";
CMD1.userSection[0].sectionMemory          = ["RAMLS_ALL"];
CMD1.userSection[1].$name                  = "CODESTART";
CMD1.userSection[1].sectionName            = "codestart";
CMD1.userSection[1].sectionMemory          = ["RAMM0"];

/**
 * Pinmux solution for unlocked pins/peripherals. This ensures that minor changes to the automatic solver in a future
 * version of the tool will not impact the pinmux you originally saw.  These lines can be completely deleted in order to
 * re-solve from scratch.
 */
analog1.analog.$suggestSolution                      = "ANALOG";
analog1.analog["a15/c7Pin"].$suggestSolution         = "A15/C7";
analog1.analog["a2/c9, gpio224Pin"].$suggestSolution = "A2/C9, GPIO224";
analog1.analog["a3/c5, gpio242Pin"].$suggestSolution = "A3/C5, GPIO242";
analog1.analog["c4/a14Pin"].$suggestSolution         = "C4/A14";
