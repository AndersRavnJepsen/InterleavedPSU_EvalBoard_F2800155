/*******************************************************
 * @ Author: ARJ
 * @ Create Time: 2025-08-19 11:03:20
 * @ Modified by: ARJ
 * @ Modified time: 2025-09-15 14:31:42
 * @ Description:
 *******************************************************/

#include "driverlib.h"
#include "device.h"
#include "board.h"
#include "c2000ware_libraries.h"
#include "F280015x_Device.h" // Header for bitfield commands.

#include "Config.h"
#include "PSU.h"

// ============ Prototypes ==============
void system_init();
bool system_ready();

float32_t setpoint = 0.0f;
bool somethings_rotten_in_the_state_of_la_la_land = false;
int state = 0;

// ============================== STATE MACHINE SETUP ====================================================
// Initialize state pointers
void (*state_Ptr)(); // Base States pointer

// Declare State function prototypes
void init_state();
void idle_state();
void softStart_state();
void run_state();
void fault_state();

void main()
{
    // Run the system initializations. Some settings (like initial duty cycle) are overwritten by settings in Config.h system_init();
    system_init();
    // At the moment we dont run an interrupt for the ADC, to avoid the overhead.
    // Instead we simply check the flag in each loop, to see if the four measurements are ready.
    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;

    // Make sure INT1 flag is cleared initially.
    // Test, run for a short while, then disable pwms
    // SysCtl_delay(3000);
    // State-machine initialization
    state_Ptr = &init_state;

    while (1)
    {
        // State machine entry & exit point
        (*state_Ptr)(); // jump to a state function
    }
}

// ####################################################################################################################
// ###################################################################################################################

void init_state()
{
    state = 1;

    // 1) Force outputs LOW (A/B) and stop ADC triggers
    EPwm1Regs.AQCSFRC.bit.CSFA = 1;
    // EPwm1Regs.AQCSFRC.bit.CSFB = 1;
    EPwm2Regs.AQCSFRC.bit.CSFA = 1;
    // EPwm2Regs.AQCSFRC.bit.CSFB = 1;
    EPwm3Regs.AQCSFRC.bit.CSFA = 1;
    // EPwm3Regs.AQCSFRC.bit.CSFB = 1;
    EPwm4Regs.AQCSFRC.bit.CSFA = 1;
    // EPwm4Regs.AQCSFRC.bit.CSFB = 1;

    // Disable ADC triggers
    EPwm1Regs.ETSEL.bit.SOCAEN = 0;
    EPwm2Regs.ETSEL.bit.SOCAEN = 0;
    EPwm3Regs.ETSEL.bit.SOCAEN = 0;
    EPwm4Regs.ETSEL.bit.SOCAEN = 0;

    // 2) Stop TBCLK while we write period and compare values.
    EALLOW;
    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0;
    EDIS;

    // 3) Load initial period/compare.
    EPWM_setTimeBasePeriod(ePWM1_BASE, INITIAL_PERIOD_COUNT); // slaves linked to EPWM1 if configured
    EPWM_setCounterCompareValue(ePWM2_BASE, EPWM_COUNTER_COMPARE_A, INITIAL_COMPARE_VALUE);
    EPWM_setCounterCompareValue(ePWM3_BASE, EPWM_COUNTER_COMPARE_A, INITIAL_COMPARE_VALUE);
    EPWM_setCounterCompareValue(ePWM4_BASE, EPWM_COUNTER_COMPARE_A, INITIAL_COMPARE_VALUE);
    EPWM_setCounterCompareValue(ePWM1_BASE, EPWM_COUNTER_COMPARE_A, INITIAL_COMPARE_VALUE);

    // Ensure the "master" pwm counter is zero.
    EPwm1Regs.TBCTR = 0;

    // 4) Start TBCLK and broadcast a sync so slaves latch TBPRD/CMP and align
    EALLOW;
    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;
    EDIS;

    // Force a sync pulse, to let pwm2-4 fire a global load event for transfering TBPRD and CMPA values from shadow.
    EPWM_forceSyncPulse(EPWM1_BASE);

    // short tea-time break. (let stuff settle.)
    SysCtl_delay(64);

    // 5) Keep outputs forced LOW and SOCA disabled; clear any stale TZ flags
    uint16_t const TZCLR_MASK1 = (EPWM_TZCLR_CBC | EPWM_TZCLR_OST |
                                  EPWM_TZCLR_DCAEVT1 | EPWM_TZCLR_DCAEVT2 |
                                  EPWM_TZCLR_DCBEVT1 | EPWM_TZCLR_DCBEVT2);

    EALLOW;
    EPwm1Regs.TZCLR.all = TZCLR_MASK1;
    EPwm2Regs.TZCLR.all = TZCLR_MASK1;
    EPwm3Regs.TZCLR.all = TZCLR_MASK1;
    EPwm4Regs.TZCLR.all = TZCLR_MASK1;
    EDIS;

    // 6) Hand off to IDLE
    state_Ptr = &idle_state;
}



void idle_state()
{
    state = 2;

    // 0) Stay safe until we’re ready
    setpoint = 0.0f;
    // DCL_resetPI_C7(&pi_current1);
    // DCL_resetPI_C7(&pi_current2);
    // DCL_resetPI_C7(&pi_current3);
    // DCL_resetPI_C7(&pi_current4);

    // If any prerequisite (VIN, temperature, GPIO interlocks, etc.) fails → remain in IDLE
    if (!system_ready())
    {
        // keep outputs forced low and triggers off
        EPwm1Regs.AQCSFRC.bit.CSFA = 1;
        EPwm2Regs.AQCSFRC.bit.CSFA = 1;
        EPwm3Regs.AQCSFRC.bit.CSFA = 1;
        EPwm4Regs.AQCSFRC.bit.CSFA = 1;
        EPwm1Regs.ETSEL.bit.SOCAEN = 0;
        EPwm2Regs.ETSEL.bit.SOCAEN = 0;
        EPwm3Regs.ETSEL.bit.SOCAEN = 0;
        EPwm4Regs.ETSEL.bit.SOCAEN = 0;
        return;
    }

    // // 1) Configure CMPSS for soft-start by increasing a cycle-by-cycle current limit.
    // // SysConfig: CTRIPH -> DCAEVT2 (async), CBC enabled on EVT2, OSHT disabled.
    // // Set the initial DAC value for the current-protection comparator.
    // // This will be increased for a softstart ramp.
    // CmpssLite3Regs.DACHVALS.bit.DACVAL = INITIAL_SOFTSTART_CMPSS_VALUE;

    // // 2) Clear any stale trips
    // // TODO: check up on these, and add for the other pwms
    // EALLOW;
    // EPwm1Regs.TZCLR.bit.OST = 1;
    // EPwm1Regs.TZCLR.bit.CBC = 1;
    // EPwm1Regs.TZCLR.bit.DCAEVT1 = 1;
    // EPwm1Regs.TZCLR.bit.DCAEVT2 = 1;
    // EPwm1Regs.TZCLR.bit.DCBEVT1 = 1;
    // EPwm1Regs.TZCLR.bit.DCBEVT2 = 1;
    // EDIS;

    // 3) Release outputs and enable ADC triggers
    EPwm1Regs.AQCSFRC.bit.CSFA = 0;
    EPwm2Regs.AQCSFRC.bit.CSFA = 0;
    EPwm3Regs.AQCSFRC.bit.CSFA = 0;
    EPwm4Regs.AQCSFRC.bit.CSFA = 0;

    EPwm1Regs.ETSEL.bit.SOCAEN = 1;
    EPwm2Regs.ETSEL.bit.SOCAEN = 1;
    EPwm3Regs.ETSEL.bit.SOCAEN = 1;
    EPwm4Regs.ETSEL.bit.SOCAEN = 1;

    // Clear ADC EoS flag once before starting
    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;

    // 4) Hand off to soft-start (DAC will ramp there; OSHT remains disabled here)
    state_Ptr = &softStart_state;


// // DEEEBUUUUUG
//     // Clean up TZ latches once
//     uint16_t const TZCLR_MASK2 = (EPWM_TZCLR_INT | EPWM_TZCLR_OST |
//                                     EPWM_TZCLR_DCAEVT1 | EPWM_TZCLR_DCAEVT2 |
//                                     EPWM_TZCLR_DCBEVT1 | EPWM_TZCLR_DCBEVT2);
//     EALLOW;
//     EPwm1Regs.TZCLR.all = TZCLR_MASK2;
//     EPwm2Regs.TZCLR.all = TZCLR_MASK2;
//     EPwm3Regs.TZCLR.all = TZCLR_MASK2;
//     EPwm4Regs.TZCLR.all = TZCLR_MASK2;
//     EDIS;

//     CmpssLite3Regs.DACHVALS.bit.DACVAL = INITIAL_ONESHOT_CMPSS_VALUE;


//     EPwm1Regs.TZSEL.bit.DCAEVT2 = 0; // Disable CBC
//     EPwm1Regs.TZSEL.bit.DCAEVT1 = 0; // Enable one-shot

// state_Ptr = &run_state;
}



// ======= Tuning (codes are CMPSS DAC codes, not amps) =======
// Compute these once from Vref/VDDA
#define SOFTSTART_RAMP_LIMIT (/* ceiling during softstart */ 2989) // e.g. ~3 A
#define HARD_OC_DAC_CODE (/* hard OC for RUN        */ 850)        // e.g. ~10 A
#define SOFTSTART_DAC_STEP (/* DAC steps per update */ 2)          // ~6.5 mA per update with your LSB
#define SOFTSTART_UPDATE_DIV (/* update every N calls */ 120)
#define SOFTSTART_DONE_COUNT (/* promote after M clean */ 4)

static uint16_t softstart_loop_counter = 0;
static uint16_t no_cbc_count = 0; // Counting number of rounds without a CBC being triggered.

void softStart_state()
{
    state = 3;

    // 1) DAC ramp: update only every SOFT_DAC_UPDATE_DIV calls
    if (++softstart_loop_counter >= SOFTSTART_UPDATE_DIV)
    {
        softstart_loop_counter = 0;

        // // Get current DAC value and update. Clamp if the specified limit has been reached.
        // uint16_t current_dac_value = CmpssLite3Regs.DACHVALA.bit.DACVAL;
        // if (current_dac_value > SOFTSTART_RAMP_LIMIT)
        // {
        //     uint16_t next_dac_value = current_dac_value - SOFTSTART_DAC_STEP;
        //     CmpssLite3Regs.DACHVALS.bit.DACVAL = (next_dac_value > SOFTSTART_RAMP_LIMIT) ? SOFTSTART_RAMP_LIMIT : next_dac_value;
        // }
    }

    // // 2) Read the trip zone CBC flags, count up if triggered, otherwise clear counter.
    // uint16_t cbc_triggered = (EPwm1Regs.TZCBCFLG.all | EPwm2Regs.TZCBCFLG.all | EPwm3Regs.TZCBCFLG.all | EPwm4Regs.TZCBCFLG.all);
    // if (cbc_triggered)
    // {
    //     no_cbc_count = 0;
    // }
    // else if (no_cbc_count < 0xFFFF) // Prevent overflow.
    // {
    //     no_cbc_count++;
    // }

    // // Clear CBC flags.
    // EALLOW;
    // EPwm1Regs.TZCLR.bit.CBC = 1;
    // EPwm2Regs.TZCLR.bit.CBC = 1;
    // EPwm3Regs.TZCLR.bit.CBC = 1;
    // EPwm4Regs.TZCLR.bit.CBC = 1;
    // EDIS;

    // 3) If no triggers happened for a while, move to normal state. If ramp limit is reached, maybe something is wrong?
    // TODO: If limit was reached we're pulling too much current - halt the system. (WHere should we do this?)
    if (no_cbc_count >= SOFTSTART_DONE_COUNT)
    {

        // Clean up TZ latches once
        uint16_t const TZCLR_MASK2 = (EPWM_TZCLR_INT | EPWM_TZCLR_OST |
                                      EPWM_TZCLR_DCAEVT1 | EPWM_TZCLR_DCAEVT2 |
                                      EPWM_TZCLR_DCBEVT1 | EPWM_TZCLR_DCBEVT2);
        EALLOW;
        EPwm1Regs.TZCLR.all = TZCLR_MASK2;
        EPwm2Regs.TZCLR.all = TZCLR_MASK2;
        EPwm3Regs.TZCLR.all = TZCLR_MASK2;
        EPwm4Regs.TZCLR.all = TZCLR_MASK2;
        EDIS;

        // Set final hard-OC (one-shot) threshold and change from CBC to one-shot
        // TODO: this prolly needs to be changed so we're still running CBC - for development use one-shot for safety.
        CmpssLite3Regs.DACHVALS.bit.DACVAL = INITIAL_ONESHOT_CMPSS_VALUE;

        EALLOW;
        EPwm1Regs.TZSEL.bit.DCAEVT2 = 0; // Disable CBC
        EPwm1Regs.TZSEL.bit.DCAEVT1 = 1; // Enable one-shot
        EPwm2Regs.TZSEL.bit.DCAEVT2 = 0;
        EPwm2Regs.TZSEL.bit.DCAEVT1 = 1;
        EPwm3Regs.TZSEL.bit.DCAEVT2 = 0;
        EPwm3Regs.TZSEL.bit.DCAEVT1 = 1;
        EPwm4Regs.TZSEL.bit.DCAEVT2 = 0;
        EPwm4Regs.TZSEL.bit.DCAEVT1 = 1;

        // Change to RUN state.
        state_Ptr = &run_state;
        return;
    }

    // 4) Soft-start fail guard.
    if ((CmpssLite3Regs.DACHVALA.bit.DACVAL <= SOFTSTART_RAMP_LIMIT) && cbc_triggered)
    {
        // We reached the limit but still tripping → go safe
        // Force outputs low and move to FAULT
        EALLOW;
        EPwm1Regs.TZSEL.bit.DCAEVT1 = 1; // ensure OSHT available
        EPwm1Regs.TZFRC.bit.OST = 1;     // trip now.

        EPwm2Regs.TZSEL.bit.DCAEVT1 = 1;
        EPwm2Regs.TZFRC.bit.OST = 1;

        EPwm3Regs.TZSEL.bit.DCAEVT1 = 1;
        EPwm3Regs.TZFRC.bit.OST = 1;

        EPwm4Regs.TZSEL.bit.DCAEVT1 = 1;
        EPwm4Regs.TZFRC.bit.OST = 1;

        EDIS;
        state_Ptr = &fault_state;
    }
}

void run_state()
{
    EPwm1Regs.TZSEL.bit.DCAEVT2 = 0;////////////////
    state = 4;
    if (AdcaRegs.ADCINTFLG.bit.ADCINT1)
    {
        // GpioDataRegs.GPATOGGLE.bit.GPIO24 = 1;
        //  debug - check timing
        //  GpioDataRegs.GPASET.bit.GPIO23 = 1;
        //  uint16_t val = AdcaResultRegs.ADCRESULT0;
        // current_loop_all_2(); DCL_current_loop_C7();
        // AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;
        //  clear interrupt flag gets done at the end of my DCL function...
        //  GpioDataRegs.GPACLEAR.bit.GPIO23 = 1;
    }
}

void fault_state()
{
    state = 99;
    // Wallow in self-pity - just keep whining.

    somethings_rotten_in_the_state_of_la_la_land = true;
    while (1)
        NOP;
}

void system_init()
{
    // ================== Run the DriverLib/SysConfig initializations ===================
    Device_init();

    // Initialize device clock and peripherals
    Device_initGPIO();

    // Disable pin locks, enable pull-ups.
    Interrupt_initModule();

    // Init PIE, clear PIE. Disables CPU interrupts.
    Interrupt_initVectorTable();

    // Init PIE vector table w. pointers to ISR's
    Board_init();

    // PinMux and Peripheral Initialization.
    C2000Ware_libraries_init(); // C2000Ware Library initialization. (DCL, FPU)

    // ================== End of DriverLib/SysConfig initializations ===================
    // ================== Fix various issues from SysConfig ===================
    // Pwm2-4 would initially be high. Force low.
    // EALLOW;
    // Configure pwm1 to use the one-shot latch for the sync out pulse.
    EPWM_enableOneShotSync(EPWM1_BASE);

    // // Hold pwm outputs LOW, while we fix the configuration.
    // EPwm1Regs.AQCSFRC.bit.CSFA = 1;
    // EPwm2Regs.AQCSFRC.bit.CSFA = 1;
    // EPwm3Regs.AQCSFRC.bit.CSFA = 1;
    // EPwm4Regs.AQCSFRC.bit.CSFA = 1;
    // // Disable the clock for the pwm's
    // EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;
    // EDIS;
    // // Disable ADC triggers while configuring:
    // EPwm1Regs.ETSEL.bit.SOCAEN = 0;
    // EPwm2Regs.ETSEL.bit.SOCAEN = 0;
    // EPwm3Regs.ETSEL.bit.SOCAEN = 0;
    // EPwm4Regs.ETSEL.bit.SOCAEN = 0;
    // // Now, set the initial top counter value (TBPRD) and the compare value (CMPA) from definitions in Config.h
    // EPWM_setTimeBasePeriod(ePWM1_BASE, INITIAL_PERIOD_COUNT);
    // Pwm2-4 period are linked to pwm1.
    // EPWM_setCounterCompareValue(ePWM4_BASE, EPWM_COUNTER_COMPARE_A, INITIAL_COMPARE_VALUE);
    // EPWM_setCounterCompareValue(ePWM3_BASE, EPWM_COUNTER_COMPARE_A, INITIAL_COMPARE_VALUE);
    // EPWM_setCounterCompareValue(ePWM2_BASE, EPWM_COUNTER_COMPARE_A, INITIAL_COMPARE_VALUE);
    // EPWM_setCounterCompareValue(ePWM1_BASE, EPWM_COUNTER_COMPARE_A, INITIAL_COMPARE_VALUE);
    // // Ensure master starts at CTR=0 (while TBCLK stopped)
    // EPwm1Regs.TBCTR = 0;
    // // Start TBCLK to let the pwm's transfer values from shadow to active registers.
    // EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;
    // // Force a sync pulse, to let pwm2-4 fire a global load event for transfering TBPRD and CMPA values from shadow.
    // EPWM_forceSyncPulse(EPWM1_BASE);
    // // 8) Small delay then release continuous force
    // EDIS; // SysCtl_delay(64);
    // release in idle state
    // EALLOW;
    // EPwm1Regs.AQCSFRC.bit.CSFA = 0;
    // EPwm2Regs.AQCSFRC.bit.CSFA = 0;
    // EPwm3Regs.AQCSFRC.bit.CSFA = 0;
    // EPwm4Regs.AQCSFRC.bit.CSFA = 0;
    // // 9) Re-enable SOCA if desired (and set source/prescale as needed)
    // EPwm1Regs.ETSEL.bit.SOCAEN = 1; //EPwm1Regs.ETPS.bit.SOCAPRD = 1;
    // EPwm2Regs.ETSEL.bit.SOCAEN = 1; //EPwm2Regs.ETPS.bit.SOCAPRD = 1;
    // EPwm3Regs.ETSEL.bit.SOCAEN = 1; //EPwm3Regs.ETPS.bit.SOCAPRD = 1;
    // EPwm4Regs.ETSEL.bit.SOCAEN = 1; //EPwm4Regs.ETPS.bit.SOCAPRD = 1;
    // EDIS; // // Clear any latched trips
    // // TODO: check up on these, and add for the other pwms
    // EALLOW;
    // EPwm1Regs.TZCLR.bit.OST = 1; EPwm1Regs.TZCLR.bit.CBC = 1;
    // EPwm1Regs.TZCLR.bit.DCAEVT1 = 1; EPwm1Regs.TZCLR.bit.DCAEVT2 = 1;
    // EPwm1Regs.TZCLR.bit.DCBEVT1 = 1; EPwm1Regs.TZCLR.bit.DCBEVT2 = 1;
    // EDIS;
    // Enable Global Interrupt (INTM) and real time interrupt (DBGM)
    EALLOW;
    EINT;
    ERTM;
    EDIS;
}

// Function to determine if we are ready to do a softstart
bool system_ready()
{
    return true;
}
